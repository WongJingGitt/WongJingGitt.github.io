- ### 序： 

    事请的起因是最近想用博客把日常工作中遇到的一些坑记录下来  

----

- ### 博客的选择：

    既然有了这个想法，就开始了解目前博客的主流方式
    > 1. 直接用第三方提供的博客。如：CSDN、掘金、简书、知乎等  
    > 2. 使用第三方工具自己搭建。如：Hexo等  
    
    我选择了自己搭建，主要是喜欢自己动手的快乐。  
    
    了解了下Hexo，感觉挺麻烦的，每次写新博客时还要使用CLI命令创建新文章。  
    我这个人比较 “懒” 。我想要的效果是：定义一个博客根目录，在根目录中用文件夹分类博客类型，然后把本地的层级映射到博客前端。  
    这样我在新增博客的时候直接Push到Github仓库就可以了。在新增的时候不用做额外的操作，只要新增文件夹或者文件就可以了。  
    
    **所以决定还是自己写一套逻辑，搭建一个简单的博客**  

----

- ### 技术方案：  

    既然决定自己写，就开始着手了。  
    首先，博客的后端，我选择用了[Github Pages](https://pages.github.com/)。Github Pages是一个静态文件托管服务器。用来做博客的后端再适合不过了。  
    前端我决定用 [React](https://react.dev/) + [Semi Design](https://semi.design/zh-CN/)  
    
    <table>
        <thead>
            <tr>
                <th>类型</th>
                <th>实现方案</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>前端</td>
                <td>React</td>
            </tr>
            <tr>
                <td>前端样式布局</td>
                <td>Semi Design</td>
            </tr>
            <tr>
                <td>后端</td>
                <td>Github Pages</td>
            </tr>
        </tbody>
    </table>

----

- ### 第一个坑：本地文件层级的映射  

    上面提到，我想要的效果是**把本地的博客文件夹映射到博客前端**，这里就遇到了第一个问题。  
    **Github Pages是一个静态文件托管服务器，不支持xhr类型的API请求。**  
    也就是说，现在面临一个问题，如何把博客的目录层级映射到博客前端。  
    想了一下，既然Github Pages是一个静态文件服务器，那么我是不是可以**把博客的目录层级写到一个文件里，然后前端请求这个文件来解析目录层级。**  
    于是乎，我把配置文件写好，放进了Github Pages。发现可以请求到！  

    ![](https://wongjinggitt.github.io/images/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E7%9B%AE%E5%BD%95%E5%B1%82%E7%BA%A7%E8%AF%B7%E6%B1%82.png)
    
    但是这样又有一个新的问题，如果使用这种方式，我在新增博客的时候，还是需要写配置文件。违背了我的初衷。  
    所以，我决定写一个脚本。这个脚本要做的事情是  
    > 1. 递归博客文件夹，把所以的子文件夹与文件夹写进配置文件。  
    > 2. 推送本地文件到Github仓库。  
    
    也就是说，**在推送之前用脚本递归博客文件夹，写进配置文件**。  
    这样就解决了手动文件更新配置文件的问题。 
    ```python
    import json
    import os
    from datetime import datetime
    from os import path
    import subprocess
    
    
    class Push:
    
        def __init__(self):
            self._root_path = path.abspath(path.dirname(__file__))
            self._config_path = path.join(self._root_path, 'config')
            self._blog_path = path.join(self._root_path, 'blog')
            self.__walker()
            self.__update()
    
        def __walker(self):
            hierarchy = {
                "type": "directory",
                "name": "blog",
                "path": "",
                "children": []
            }
    
            for root, dirs, files in os.walk(self._blog_path):
                current_dir = hierarchy
                rel_path = os.path.relpath(root, self._blog_path)
                if rel_path != ".":
                    sub_dirs = rel_path.split(os.sep)
                    for sub_dir in sub_dirs:
                        found = False
                        for child in current_dir["children"]:
                            if child["name"] == sub_dir:
                                current_dir = child
                                found = True
                                break
                        if not found:
                            new_dir = {
                                "type": "directory",
                                "name": sub_dir,
                                "path": os.path.join(current_dir["path"], sub_dir),  # 更新相对路径
                                "children": []
                            }
                            current_dir["children"].append(new_dir)
                            current_dir = new_dir
    
                for file in files:
                    current_dir["children"].append({
                        "type": "file",
                        "name": file,
                        "path": os.path.join(current_dir["path"], file)  # 更新相对路径
                    })
    
            with open('config/blog_list.json', 'w', encoding='utf-8') as fw:
                json.dump(hierarchy, fw, ensure_ascii=False)
                fw.close()
    
        def __update(self):
            subprocess.run(['git', 'add', '.'])
            subprocess.run(['git', 'commit', '-m', datetime.now().strftime("%Y-%m-%d %H:%M:%S")])
            subprocess.run(['git', 'push', '-u', 'origin', 'main'])
    
    
    if __name__ == '__main__':
        Push()
    ```    
  
    所以，每次写完博客，我只需要下运行下这个脚本就可以了。  

----

- ### 第二个坑：Markdown解析  
    
    Markdown解析真的是一个特别头疼的事。  
    我用的是 `react-markdown` 这个库，这个库可以把Markdown语法转义成html。  

    用法倒是挺简单的：  
    
    ```jsx
    <ReactMarkdown children={markdown} />
    ```  
  
    像这样放进需要渲染的容器里就好了。  
    但是有个很坑的事请，**没有样式！**  
  
    ![](https://wongjinggitt.github.io/images/博客搭建/无样式渲染.png)  

    就像这样，我人麻了，最基本的code样式、引用样式都没有。  

    于是我便去翻github，发现code样式需要结合代码高亮插件一起使用。  
    
    开始改代码  
    
    ```jsx
    <ReactMarkdown children={textText} components={{
        code({ inline, className, children, ...data }) {
            const match = /language-(\w+)/.exec(className || '');
            return !inline && match ? (
                <div>
                    <SyntaxHighlighter style={ oneLight } language={match[1]} PreTag="div" >
                        {String(children).replace(/\n$/, '')}
                    </SyntaxHighlighter>
                </div>
            ) : <code>{children}</code>
        }
    }} />
    ```
  
    看下效果  
    
    ![](https://wongjinggitt.github.io/images/博客搭建/代码高亮.png)

    这下好多了，但还是很丑。这样的博客我自己看着都头疼。  

    我看下了，突然发现，它在做代码高亮处理时，是在 `components` 下面改写了 `code` ，那是不是其他的组件也可以被改写呢？  
    
    怀着试一试的心态，我尝试改了下其他组件。  
    还真是我想的这样。

    于是我开始利用 `Semi Design` 去改写Markdown渲染样式。
    
    也就是说，整体的逻辑是：

    > `Markdown` --解析--> `react-markdown` --覆写样式--> `Semi Design` --渲染--> `界面`


- ### 未完待续...  

