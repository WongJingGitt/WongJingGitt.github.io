- ## [序言](#序言)
    
    记录一下关于面向对象编程的一些总结。

- ## [什么是面向对象编程？](/什么是面向对象编程？)

    > 面向对象程序设计(Object Oriented Programming)作为一种新方法，其本质是以建立模型体现出来的抽象思维过程和面向对象的方法。模型是用来反映现实世界中事物特征的。任何一个模型都不可能反映客观事物的一切具体特征，只能对事物特征和变化规律的一种抽象，且在它所涉及的范围内更普遍、更集中、更深刻地描述客体的特征。通过建立模型而达到的抽象是人们对客体认识的深化。  
    
    这是[百度百科](https://baike.baidu.com/item/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/24792?fr=ge_ala)对面向编程的解释，看起来有点晦涩难懂，说实话第一次看觉得听懵的。  

    既然是面向对象编程，那就先说一下对象。

    ### [什么是对象？](#什么是对象？)

    对象可以理解为具有实体特征的东西，比如一只兔子、一只羊、一辆汽车、一张桌子。  

    带入到实际的编程语言中，它的表现可能是：一个列表、一个字典、一个元组、一个字符串、一个函数...

    也有可能是他们的组合，一系列的数据加上一系列的函数。例如一个类的实例化对象。

    ### 什么是面向对象编程？

    对象知道是什么了，那面向对象就好理解了，面向对象的编程思想就是：**一切的编程工作都围绕对象展开。**

    我个人对于面向对象的理解是：**将一系列具有类似特征的抽象概念、逻辑，统一使用一个东西进行收纳，以便于使用。**

    说实话，这一点我感觉翻译占很大的锅，对象从名字看太抽象了。我个人认为港台的翻译“**物件导向编程**”更加容易让人理解，物件你一看就知道，这一定是个实体。  

    除了面向对象编程还有其他的一些编程范式，事件驱动编程、函数式编程、命令式编程等等。

- ## 面向对象的核心概念

    面向对象的核心概念包括以下几点：

    1. 类
    2. 对象
    3. 封装
    4. 继承
    5. 多态

    - ### 类

        > 类（Class）是面向对象程序设计（OOP，Object-Oriented Programming）实现信息封装的基础。类是一种用户定义的引用数据类型，也称类类型。每个类包含数据说明和一组操作数据或传递消息的函数。类的实例称为对象。

        这是[百度百科](https://baike.baidu.com/item/%E7%B1%BB/6824577?fromModule=lemma_inlink)对于类的解释。  

        上面在讲面什么是面向对象的时候，我提到了“将一系列具有类似特征的抽象概念、逻辑，统一使用一个东西进行收纳”，而这个“东西”就是类。

        类就是用来封装这些抽象概念、逻辑的，可以理解为一个抽象概念的集合。 

        通过调用一个类，可以生成一个具体的对象。可以理解为：**类是一个模板，可以根据这个模板生成一系列的对象。**

        这个由类生成对象的过程，通常称为类的**实例化**。而生成的对象，通常称为类的**实例化对象**。

        一个🌰：

        ```python
        class Rabbit:
            
            def __init__(self, color, sex, name=None):
                self.__rabbit = {"color": color, "sex": sex, "name": name}
            
            @property
            def get_rabbit(self):
                return self.__rabbit      
      
            @property
            def get_color(self):
                return self.__rabbit.get('color')
                
            @property
            def get_sex(self):
                return self.__rabbit.get('sex')  
      
            @property
            def get_name(self):
                return self.__rabbit.get('name')      

      
        if __name__ == '__main__':
            rabbit_nameless = Rabbit("白色", "母")
            rabbit_hui_hui = Rabbit("灰色", "公", "灰灰")

            print(rabbit_nameless.get_color)    # 输出：白色
            print(rabbit_nameless.get_sex)      # 输出：母
            print(rabbit_nameless.get_name)     # 输出：None
            print(rabbit_nameless.get_rabbit)   # 输出：{'color': '白色', 'sex': '母', 'name': None}

            print(rabbit_hui_hui.get_color)     # 输出：灰色
            print(rabbit_hui_hui.get_sex)       # 输出：公
            print(rabbit_hui_hui.get_name)      # 输出：灰灰
            print(rabbit_hui_hui.get_rabbit)     # 输出：{'color': '灰色', 'sex': '公', 'name': '灰灰'}
        ```
      
        在这个例子中定义了一个`Rabbit`类，表示兔子这一个生物的抽象概念。通过实例化`Rabbit`类，可以得到具体一只兔子的实例化对象。

        这里的`Rabbit`类就可以理解为模板，而通过这个模板，可以拿到一只只不同的兔子。实例化对象是有实际特征属性的，例如：`rabbit_nameless`生成了一只没有名字的、白色的、母兔子。`rabbit_hui_hui`生成了一只名字叫灰灰的、灰色的、公兔子。

        而没有实例化的`Rabbit`类，它是没有具体特征的。你不可能说兔子这种生物是白色的，母的，这样别人可能会认为你小学没毕业。

        - **再举一个生活中的例子，“我的世界”这款游戏。**
      
          在“我的世界”这款游戏的上帝模式中，你可以通过装备“山羊“这个生物类别，然后点击左键就可以在你的眼前生成一只山羊。
          而这一只生成的山羊是具有一系列实际特征的，例如生成了一只白色的母羊，一只灰色的公羊等等。

        这里把它带入到编程语言中，装备的”山羊“这个生物类别就可以理解为`Rabbit`类，只不过由兔子这个生物类别变成了山羊这个生物类别。而通过这个生物类别生成的山羊，就是`Rabbit`类的实例化对象，只不过由兔子变成的山羊。而点击左键这个生成的动作就是实例化
        
    - ### 对象

        上面简单的说了下对象的概念。在面向对象中，对象是类的实例化，是类具体的实体。而类则是一系列具有相同特征的抽象概念的合集。
        那也就是说，**一个类可以有无数个不同的实例化对象**。  
        
        那么这里就引申出一个问题，既然有无数个不同的实例化对象，那么在类里面是怎么表示这些对象的？
        例如上面提到的兔子类，当我在实例化之后有两个实例化对象`rabbit_nameless`和`rabbit_hui_hui`，类里面是怎么知道它们哪一个是哪一个的？为什么不会出现在实例化时把`rabbit_nameless`的属性赋值给`rabbit_hui_hui`，而`rabbit_hui_hui`的属性赋值给`rabbit_nameless`的情况？
        
        要解释这个问题，可能要涉及到后续要讲到的：**封装**这个概念。这里先可以简单的理解：**每个实例化对象的内部都是互相隔离的**，它们都拥有各自不同的特点，尽管它们在外表上看起来可能相同。
        
        所以，参考小学数学中的一个例子：在解方程时，如果有一个未知数我们会假设一个x或者y，用来代替这个未知数，然后带入公式中。
        这里也是同理：在类中，一个个不同的实例化对象也相当于一个个不同的未知数，而这个“未知数”我们通常也用一个约定成俗的关键字来表示。在Python中写作`self`，在JavaScript或者Java等一些其他语言中写作`this`。

        所以，在类中(Python)，实例化对象通过关键字`self`来表示，而实例化对象的特征属性，则通过`self.xxx`来表示。

        一个实例化对象通常具有三大属性：**状态**、**行为**、**标识**。

        #### 状态
            
        状态很好理解，用于描述对象的具体特征或是属性。  
    
        例如：还是上面的例子，我们定义了2只不同的兔子，`self.__rabbit`描述了它具体的一些特征，这个就是对象的属性，也可以称之为状态。  

        甚至如果需要，你还可以给它加上其他的属性：

        ```python
        class Rabbit:
        
            def __init__(self, color, sex, name=None):
                self.__rabbit = {"color": color, "sex": sex, "name": name}
                self.__alive = True
        ```
      
        上面的例子中，新增了一个`self.__alive`的属性，用于描述兔子是否活着。

        这里再引申几个额外的点：
        
        1. 静态属性与实例属性
        2. 私有属性与公有属性

        >**静态属性：** 静态属性是类的属性，归属于类本身。因为它归属于类本身，因此使用它不需要实例化对象，可以直接使用。  
        **实例属性：** 实例属性是一个具体实例化对象拥有的属性，它之前需要先进行实例化。
            
        可以理解为静态属性是这个类的通用描述，而实例属性是某一个具体个体的描述。
        
        例如：还是上面这个兔子的例子。众所周知，兔子这个物种通常是具有4条腿的。排除个别特殊因素，这个是兔子这个物种的通用属性，因此可以将它定义为静态属性。
        
        ```python
        class Rabbit:
      
            LEGS = 4    
            EYES = 2  
      
            def __init__(self, color, sex, name=None):
                self.__rabbit = {"color": color, "sex": sex, "name": name}
                self.__alive = True
        
        if __name__ == '__main__':
            rabbit_nameless = Rabbit("白色", "母")
            rabbit_hui_hui = Rabbit("灰色", "公", "灰灰")
      
            print(rabbit_nameless.LEGS)     # 4
            print(rabbit_hui_hui.LEGS)      # 4
            print(Rabbit.LEGS)              # 4      
      
            print(rabbit_nameless.EYES)     # 2
            print(rabbit_hui_hui.EYES)      # 2  
            print(Rabbit.EYES)              # 2          
        ```
        
        从这里看，静态属性的作用好像“很有限”，这些明明实例属性也可以代替嘛。（我刚学的时候就是这样想的 = =）
        这个点如果是初学，理解起来确实会有一些不清晰。简单说一下我理解的原因：
        
        假设有一个类，是封装了浏览器启动的类。而整个运行过程中，可能会经历很多个不同的脚本，但是浏览器的上下文实例对象只有一个。这个时候应该
        怎么将它跨不同的脚本联系起来呢？直接实例化的话，各个实例化对象之间是互相隔离的，因此拿到的浏览器实例化对象肯定也是不一样的。
        
        所以这个时候，静态属性就派上用场了。因为静态属性是类级别的，只要你不动它，它就是亘古不变的，不管是实例化多少次，它始终是它，一如既往的陪在你身边。

        也是同理，因为静态属性在整个类的生命周期中是全局共享的，所以，同理你只要在一个地方更改了它的值，那么所有实例化对象都会受到影响。而实例属性则相反，它只属于实例化对象，不会影响其他对象。

        ```python
        class Rabbit:
      
            LEGS = 4    
            EYES = 2  
      
            TOTAL_ALIVE = 0
            
            def __init__(self, color, sex, name=None, alive=True):
                self.__rabbit = {"color": color, "sex": sex, "name": name}
                self.__alive = alive
                if alive:
                    Rabbit.TOTAL_ALIVE += 1
      
            def change_alive_status(self):
                if self.__alive:
                    self.__alive = False
                    Rabbit.TOTAL_ALIVE -= 1
        if __name__ == '__main__':
            rabbit_nameless = Rabbit("白色", "母")
            rabbit_hui_hui = Rabbit("灰色", "公", "灰灰")

            print(Rabbit.TOTAL_ALIVE)      # 2

            rabbit_nameless.change_alive_status()
            print(Rabbit.TOTAL_ALIVE)      # 1
        ```

        > **私有属性：** 无法从外部直接进行读取、更改的属性  
        **公有属性：** 可以从外部直接进行读取、更改的属性
    
        怎么说呢，还是简单举个例子吧，上面提到的类属性是全局共享的，因此我们会把一些通用的数据放在类属性中。
        但是这样也有一个风险：那就是，万一我在类属性中定义的一个属性，在某个地方被改了，那么用到这个属性的地方可能都会报错。

        所以这里就引申出了私有属性这个概念，私有属性只能在类的内部直接使用，在外部无法直接读取和修改。不管是实例化对象属性还是类属性，都遵循这个原则。  

        私有属性怎么定义呢？Python中，在变量名前面加上两个下划线，就是私有属性了。

        ```python
        class Rabbit:
      
            __LEGS = 4    
            __EYES = 2  
      
            __TOTAL_ALIVE = 0
            
            def __init__(self, color, sex, name=None, alive=True):
                self.__rabbit = {"color": color, "sex": sex, "name": name}
                self.__alive = alive
                if alive:
                    self.__TOTAL_ALIVE += 1
      
            def change_alive_status(self):
                if self.__alive:
                    self.__alive = False
                    self.__TOTAL_ALIVE -= 1
        if __name__ == '__main__':
            rabbit_nameless = Rabbit("白色", "母")
            rabbit_hui_hui = Rabbit("灰色", "公", "灰灰")

            print(Rabbit.__TOTAL_ALIVE)      # 报错
        ```
      
        为了确保私有属性不被外部进行预期外的更改，通常会配置一些方法，来对私有属性进行操作。

        例如上面的例子，`self.__alive`被定义成了一个私有的实例化属性，所以我们无法直接读取和修改，但是我们可以通过`self.change_alive_status()`这个方法来修改它。
        而`self.change_alive_status()`在更改时是进行了额外的判断，只有`self.__alive`为`True`时才允许更改(这样比较符合实际逻辑，因为很少会出现死而复生的情况。)，并且限定了它只能赋真假值，不会接收到预期之外的值，避免一些不必要的错误。

        如果把它设置为公有属性，`self.alive`，然后手动赋值改变，你自己可能知道它只接收布尔值，但是别人不知道，所以最好还是不要把一些重要的属性直接暴露出去。

        #### 行为  

        行为就是方法也称之为函数，只是它被放在了类里面，并且可以访问类的属性。

        首先什么是函数？

        直白的理解，**函数可以理解为一套罐装的固定逻辑，并且具有输入与输出。** 类似工厂流水线中的车床工具，你把材料从一个口子放进去，出来就变成了一个个整体的零件。  

        这里的输入与输出可以是多种不同的形态，简单举一下常见的例子

        输入：
        1. 函数预设的入参。
        2. 函数没有入参，但是从外部获取了数值。
        3. 函数内部自己创建的数据。  

        输出：
        1. 函数的return语句返回的参数。
        2. 函数没有return语句，但是修改了外部的某些值。
        3. 函数产生的额外的数据与行为。

        简单的可以理解为**显示输入**、**隐式输入**、**显示输出**与**隐式输出**。

        ```python
        class Rabbit:
      
            __TOTAL_ALIVE = 0
      
            def __init__(self, color, sex, name=None, alive=True):
                self.__rabbit = {"color": color, "sex": sex, "name": name}
                self.__alive = alive
      
            def change_alive_status(self):
                # 这里从函数的外部获取了alive的值，可以理解为隐式输入
                if self.__alive:
                    self.__alive = False
                    # 这里也是从函数的外部获取了TOTAL_ALIVE的值，可以理解为隐式输入
                    self.__TOTAL_ALIVE -= 1
                # 这个函数虽然没有return语句，但是修改了外部的alive与TOTAL_ALIVE的值，可以理解为隐式输出          
      
            def change_name(self, name):
                if isenstance(name, str):
                    # 当走到这个代码段时，name传入非字符串，抛出了一个错误，产生了一个额外的行为，可以理解为隐式输出。
                    raise Exception("name must be str")
                # 这里直接从函数的入参接受了name的值，可以理解为显示输出。
                self.__rabbit["name"] = name
                # 同样的这个函数虽然没有return语句，但是修改了rabbit中的name，可以理解为隐式输出。
      
            def get_rabbit(self):
                # 显示输出与隐式输入（从外部获取的__rabbit数据）
                return self.__rabbit
        ```
      
        所以对象的行为通常用来在实例化中执行一些操作，比如改变实例的状态。

        这里严格来说其实还有一些额外的点，方法的重载与重写。重写后面的继承会讲到，但是重载在Python中其实是不存在。  

        **方法重载：**

        简单说一下我个人对于重载的理解（因为Python不存在重载，所以可能我的理解也没有特别深刻）。

        说重载之前可能要说一下数据类型，众所周知Python是一门动态类型的语言，所以数据类型可以动态的改变。

        在一些强类型语言中，例如Java，在定义变量时，必须指定变量的类型，例如int a = 1，a的类型就是int，如果传入其他的类型，就会报错。

        因此，在定义一个类方法时，在强类型的语言中，必须指定方法的参数类型。而相同的函数名，但是参数的类型不一样，它们是允许并立存在的。
        在调用的时候，会根据传入参数的类型，来决定具体调用哪个函数。

        但Python是动态类型的语言，如果在类里面写同名的方法，后面写的方法会覆盖前面的方法。哪怕你入参写出花来，也是这个铁打不动的逻辑。所以说Python中存在重载。

        不过也可以根据Python的特性，来实现类似的操作。

        首先重载的概念其实就是，针对入参或者入参的类型不同，从而执行不同的操作。

        所以如果在Python中要想实现，它可能是这样：

        ```python
        class Rabbit:
      
            def __init__(self, color, sex, name=None, alive=True):
                self.__rabbit = {"color": color, "sex": sex, "name": name}
                self.__alive = alive
      
            
        ```