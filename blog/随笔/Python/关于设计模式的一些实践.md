## 记录一些设计模式的总结，也算是学习笔记

- ### 单例模式
    
    单例模式：**保证一个类仅有一个实例，保证全局共享一个实例化对象。**

    > 在一些需要全局共享一个实例的场景下可以使用单例模式。例如：UI自动化的浏览器启动类、接口自动化的接口请求类。

    一个简单的例子：

    ```python
    class HttpRequests:
        __instance = None
        __token = None
        __headers = None
    
        def __new__(cls, *args, **kwargs):
            if cls.__instance is None and cls.__token is None:
                cls.__instance = super().__new__(cls)
                cls.__token = cls.__init()
            return cls.__instance
        
        def __init(self):
            # 获取token的代码，此处省略
            token = '....'
            return token
    ```
  
    这样在使用时，仅在第一次实例化的时候会获取到token，后续在调用时仅会返回第一次实例化的对象，不需要重复的去获取token。

    完整的http请求类可以在类的请求方法中添加add_token装饰器来控制需不需要携带token发起请求。

    ```python
    class HttpRequests:
        __instance = None
        __token = None
        __headers = None
    
        def __new__(cls, *args, **kwargs):
            if cls.__instance is None and cls.__token is None:
                cls.__instance = super().__new__(cls)
            return cls.__instance
    
        def initialization(self, callback: typing.Callable or dict):
            if not isinstance(callback, typing.Callable) and not isinstance(callback, dict):
                raise Exception(f'initialization接收的参数类型为Callable或dict，但传入的参数类型为{type(callback).__name__}')
    
            result = callback() if isinstance(callback, typing.Callable) else callback
            if not isinstance(result, dict):
                raise Exception(f'initialization返回的类型为dict，但返回的类型为{type(result).__name__}')
    
            if not result.get('token'):
                raise Exception(f'initialization返回的字段中需要包含token字段，但返回的token字段为None')
    
            if not isinstance(result.get('token'), str):
                raise Exception(f'token需要的类型为str，但实际的类型为{type(result.get("token")).__name__}')
    
            if result.get('headers') and not isinstance(result.get('headers'), dict):
                raise Exception(f'headers需要的类型为dict，但实际的类型为{type(result.get("headers")).__name__}')
    
            self.__headers = result.get('headers', None)
            self.__token = result.get('token')
    
        @staticmethod
        def add_token():
            def wrapper(function):
                def inner(*args, **kwargs):
                    should_add_token = kwargs.get('add_token', True)
                    if should_add_token:
                        headers = kwargs.get('headers', {})
                        _hp = HttpRequests()
                        headers['Authorization'] = _hp.get_token
                        kwargs['headers'] = headers
                    kwargs.pop('add_token') if kwargs.get('add_token', None) is not None else None
                    return function(*args, **kwargs)
                return inner
            return wrapper
    
        @property
        def get_token(self):
            if self.__token is None:
                raise Exception("Token is not set")
            return self.__token
    
        @retry()
        @add_token()
        @timer()
        def get(self, *args, **kwargs) -> requests.Response:
            return requests.get(*args, **kwargs)
    
        @retry()
        @add_token()
        @timer()
        def post(self, *args, **kwargs) -> requests.Response:
            return requests.post(*args, **kwargs)
    
        @retry()
        @add_token()
        @timer()
        def delete(self, *args, **kwargs) -> requests.Response:
            return requests.delete(*args, **kwargs)
    
        @retry()
        @add_token()
        @timer()
        def put(self, *args, **kwargs) -> requests.Response:
            return requests.put(*args, **kwargs)
    
        @retry()
        @add_token()
        @timer()
        def __call__(self, *args, **kwargs) -> requests.Response:
            return requests.request(*args, **kwargs)
  
    
    if __name__ == '__main__':
        hp = HttpRequests()

        resp = hp.post(
            url='http://127.0.0.1/api/user/login',
            json={"username": "WongJingGit", "password": "123456"},
            add_token=False
        )
        token = resp.json().get('assertToken')
        hp.initialization({'token': token})
        resp1 = hp.get('http://127.0.0.1/api/user/auth', add_token=False)
        resp2 = hp.get('http://127.0.0.1/api/network_report/report_list')
        print(resp1.json())
        print(resp2.json())
        print(resp1.request.headers)
        print(resp2.request.headers)    
    ```
  
要下班了，先写到这里，改天有空再继续。