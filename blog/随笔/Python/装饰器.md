- ## 装饰器 
    本文主要对装饰器的使用做出相关总结

- ## 什么是装饰器
    > **在不改变函数原有功能的前提下，为函数增加额外的功能。**  

    通常会用作一些通用性的功能，例如：日志记录、错误重试、缓存、鉴权等等

    在Python中的使用方式为，函数/类定义时在上方使用`@demo`的方式使用。

    同时装饰器支持传参，根据参数不同增加不同的操作。例如：`@retry(max_times=3, delay=2)`

- ## 自定义装饰器

    首先**装饰器本质上是一个可调用对象，可以是函数，也可以是实现了`__call__`方法的类。在使用时会把被装饰的函数作为参数传递给装饰器函数，然后再返回一个新的函数**。  
    
    并且，**装饰器在使用时，装饰器函数会在函数定义时（即模块加载时）立即执行，不论被装饰的函数是否调用。**  

    形象点理解，相当于一个二道贩子从农民手里收上来玉米，然后再二次加工做成一个包装玉米拿出去卖。在这期间玉米的本质没有变，只是在玉米原有的基础上增加一个包装。

    ### 装饰器的执行机制
    
    既然是会把被装饰的函数作为一个参数传递给装饰器函数，可以得知，装饰器函数是有一个入参是函数的。所以代码首先可以这样写。

    ```python
    def decorator(function):
        # ...其余代码
        print('装饰器的function参数为：', function.__name__)
    
    @decorator
    def main():
        pass
    ```
    上面这个例子，`main`函数就会作为入参传递给`decorator`函数。所以。运行这段代码可以发现会打印出以下结果：

    > 装饰器的function参数为： main
    
    这个时候再调用`main`函数，会发现报错了。提示`'NoneType' object is not callable`。

    这个错误表明，`main`函数现在是`None`，不是一个可调用对象。前面有提到，装饰器需要接收一个函数作为入参，同时返回一个新的函数。

    这里在调用`main`报错，是因为`decorator`函数没有返回任何内容，所以会报错。

    所以我们可以试着返回一个函数看看。

    ```python
    def demo():
        print('这是Dome函数')

    def decorator(function):
        print('装饰器的function参数为：', function.__name__)
        return demo

    @decorator
    def main():
        print('这是main')
        return 1


    if __name__ == '__main__':
        main()
    ```
  
    这段代码在`decorator`基础上返回了一个新的`demo`函数，运行`main`函数控制台打印了以下结果： 
    > 装饰器的function参数为： main   
    这是Dome函数

    这正好印证了上面的结论，装饰器会返回一个新函数。同时也得到了一个新的点，返回的函数会代替被装饰的函数  
    从上面的结果可以看出，因为运行`main`函数实际上运行的却是`decorator`返回的`demo`函数。

    同理，装饰器可以不返回函数，可以返回字符串、字典、列表。返回了这些类型后，原本的`main`函数会被替代，就不是一个函数了，所以再调用它就会报错，具体看下面的例子：

    ```python
    def decorator(function):
        return ['装饰器没有返回函数，返回了列表。']


    @decorator
    def main():
        print('这是main')
        return 1


    if __name__ == '__main__':
        print(main)
        main()
    ```
    运行上面的例子，首先它打印了列表`['装饰器没有返回函数，返回了列表。']`，然后报错`TypeError: 'list' object is not callable`。

    讲了这么多，主要是想说明一个点：装饰器本质上是将被装饰的函数作为入参传给装饰器函数，然后返回一个新的值来替代被装饰的函数，这个值可以是任意类型，但是通常情况下会返回和被装饰对象同样的类型。  

    所以依据这个道理，装饰器不仅仅可以写函数装饰器，还可以写类装饰器，譬如Python原生的dataclass。类装饰器与函数装饰器本质上类似，接收一个类，然后返回一个新的类，可以用于修改或增强类的行为。
    
    ### 带参数的装饰器  

    